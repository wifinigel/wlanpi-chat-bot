#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
A chatbot to receive commands to perform various WLAN Pi operations and 
retrieve status information.

This work is based upon the excellent article and code provided by Gareth
Dwyer in his blog article "Building a Chatbot using Telegram and Python (Part 1)".

You can find the article at: 

https://www.codementor.io/@garethdwyer/building-a-telegram-bot-using-python-part-1-goi5fncay

Thank you Gareth.
"""
import json
import logging
import os
import requests
import sys
import time
import urllib
from pprint import pprint

from transports.telegram_comms import TelegramComms
from wlanpi_commands.command import Command
from wlanpi_commands.command import register_commands
from utils.node_data_snapshot import DataSnapshot
from utils.parser import parse_cmd, lazy_parser
from utils.config import Config
from utils.constants import SUPPORTED_VERBS

logging.basicConfig(level=logging.INFO)
bot_logger = logging.getLogger('wlanpi-bot')

long_polling_timeout = 100

# read in local node config info
conf_obj = Config()
conf_obj.read_config()

# Telegram info
api_key = conf_obj.config['telegram']["bot_token"]
if not api_key:
    bot_logger.error("No api token configured in config file (check bot_token). Exiting")
    sys.exit()

chat_id = False # we may not know our chat_id initially...

if "chat_id" in conf_obj.config['telegram'].keys():
    chat_id = conf_obj.config['telegram']["chat_id"]

t = TelegramComms(api_key)

# create a messages spooling dir if required
if not t.check_spool_dir_messages_exists():
    t.create_spool_messages_dir()

# create a files spooling dir if required
if not t.check_spool_dir_files_exists():
    t.create_spool_files_dir()

# flush old spool files
t.flush_spool_dir_files()
t.flush_spool_dir_msgs()

# register all commands ready to use later
GLOBAL_CMD_DICT = register_commands(t, conf_obj)

def main():
    last_update_id = None

    # event loop
    while True:

        # check if we can get to the Telegram API, sleep if not to 
        # save lots of annoying failed HTTPS requests
        if conf_obj.config['telegram']["network_check"]:

            if not t.check_api_access():
                bot_logger.info("Looks like network access issues to Telegram - sleeping")
                time.sleep(60)
                continue

        # Process spooler queues
        if t.chat_id:
            # Process any alerts waiting in messages spooler queue
            for alert in t.get_spooler_messages_queue():
                t.send_msg(alert, t.chat_id)
        
            # Process any files waiting in files spooler queue
            for filename in t.get_spooler_files_queue():
                t.send_file(filename, t.chat_id)
            t.flush_spool_dir_files()

        # get updates from the Telegram bot
        # (Note we're using long polling, which is an extended http timeout to avoid 
        # use of rapid upstream polling of Telegram bot to check for new messages)
        #
        # Pass the ID of last rec'd message to ack message and stop it being sent again
        updates = t.get_updates(last_update_id)

        # something went wrong - maybe out Internet connection is down, sleep
        # and try again
        if not updates:
            bot_logger.info("Looks like Telegram API not responding - sleeping")
            time.sleep(60)
            continue

        # report on node status if this is a reboot or something changed
        snapshot = DataSnapshot()
        status_update = snapshot.node_status()

        if status_update and chat_id:
            t.send_msg(status_update, chat_id)

        # if we have a message to process, lets take action
        if len(updates["result"]) > 0:
            last_update_id = t.get_last_update_id(updates) + 1

            # slice out the last msg (in the case of multipe msgs being sent)
            update = updates['result'][-1]

            # extract the message text
            if "message" in update.keys():
                text = str(update["message"]["text"]).strip()
            else:
                continue

            # extract the chat ID for our response
            chat = update["message"]["chat"]["id"]

            # if we don't have a global chat_id already, write it to the config file
            if not chat_id:
                conf_obj.config['telegram']["chat_id"] = chat
                conf_obj.update_config()

            # normalize text case
            text = text.lower()
            # cleanup whitespace (inc trailing & leading space)
            text = ' '.join(text.split())

            # get list of available commands
            # TODO: don't need to do this every loop - move outside of main loop
            command_list = list(GLOBAL_CMD_DICT.keys())
            command_list.sort()
            # cmd list with spaces added in
            fixed_command_list = [e.replace("_", " ") for e in command_list]

            # parse command and expand any shortening of verbs (run, show, set, exec)
            [command, args_list] = parse_cmd(text, command_list)

            msg = "blank"

            #########################################
            # Command parsing start
            #########################################

            # Parse the message we received:
            #
            # 1. Check for exact match on 'help' or '?'
            # 2. Check for 'help all' to list all commands
            # 3. Check for 'help' + (partial)'command string' - return help screen for command 
            #    if unique match
            # 4. Check for 'help part_command_string' - return list of matching commands
            # 5. Check for exact command and execute it (e.g. show status)
            # 6. Check for partial match of command and run if unique partial 
            #    match (e.g. sh st)
            #  
            if text == 'help' or text == "?":
                # process a short help request (return everything)
                msg = ['Available command groups:\n']
                try_msg = ["\nTry 'help show' to see show commands\nEnter 'help all' to see all commands"]
                msg = msg + SUPPORTED_VERBS + try_msg
            elif text == 'help all':
                # show all commands
                msg = ['All available commands:\n']
                try_msg = ["\nTry 'help show' to see show commands"]
                msg = msg + fixed_command_list
            elif text.startswith('help '):
                # check if command matches on a lazy parse - retrun help page of comand
                # if it does
                command_str = text[5:] # slice off 'help '
                [command, args_list] = lazy_parser(command_str, fixed_command_list)
                if command:
                    msg = GLOBAL_CMD_DICT[command].help_message()
                else:
                    # process a help request with match filter (e.g. 'help sh')
                    msg = ['Filtered commands:\n']
                    cmd = text[5:]
                    match_list = list(filter(lambda x: (x.startswith(cmd)) , fixed_command_list))
                    msg = msg + match_list
            elif command in command_list:
                # check for an exact command match & execute it
                msg = GLOBAL_CMD_DICT[command].run(args_list)
            else:
                [command, args_list] = lazy_parser(text, fixed_command_list)

                if command:
                    msg = GLOBAL_CMD_DICT[command].run(args_list)
                else:
                    msg = 'Unknown command (try "help" command)'

            #########################################
            # Command parsing end
            #########################################

            bot_logger.debug("Send status data to Telegram: {}".format(msg))
            t.send_msg(msg, chat)


if __name__ == '__main__':
    main()